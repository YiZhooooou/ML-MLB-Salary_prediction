# -*- coding: utf-8 -*-
"""cs135-final-mlb-salaries.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1761-_ja__NCVz4CR_d3iYrmW-c5xGnK9

CS 135 Machine Learning Final Project
---
Jack Ortner, Johnathan Oneal, Max Shellist, Yi Zhou
"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeRegressor
import matplotlib.pyplot as plt
import seaborn as sns

batting = pd.read_csv('Batting.csv')
fielding = pd.read_csv('Fielding.csv')
salaries = pd.read_csv('Salaries.csv')
fielding

year = 2005

# get sample salaries for 1999
sample_1999 = salaries[salaries['yearID'].isin([year])]

# get features for each player
# get battings
# find battings for each player
# we need to get the previous year batting in this case 1998 betting for 1999 players
# find all players' ID
all_players = sample_1999['playerID'].tolist()

# find all battings in 1998
batting_1998 = batting[batting['yearID'].isin([year - 1])]
batting_sample = batting_1998[batting_1998['playerID'].isin(all_players)]

# note that there are some players having multiple battings in one season, so we chose to focus on thos who only have one battings
# remove all players who has more than 1 battings
batting_dict = batting_sample['playerID'].value_counts().to_dict()
new_batting = {key: val for key, val in batting_dict.items() if val == 1}

# get all player with one batting in a list
filter_batting_list = list(new_batting.keys())
filtered_batting_sample = batting_1998[batting_1998['playerID'].isin(filter_batting_list)]

# now we are adding postion data for each player
# one common situation is that some of players play multiple postion here we are only consider one postion(most common one) for each player
players = filtered_batting_sample['playerID'].value_counts().index
fielding_1999 = fielding[fielding['playerID'].isin(filter_batting_list) & fielding['yearID'].isin([year])]
filtered_fielding_sample = pd.DataFrame()
for player in players:
    player_df = fielding_1999[fielding_1999['playerID'].isin([player])]
    positions = player_df['POS'].value_counts().index
    tracker = pd.DataFrame()
    for position in positions:
        df_temp = player_df[player_df['POS'].isin([position])]
        tracker = tracker.append({'POS':position, 'games':df_temp.sum()['G']}, ignore_index=True)
    if len(tracker.index) == 0:
      pass
    else:
      id_max = tracker['games'].idxmax()
      filtered_fielding_sample = filtered_fielding_sample.append({'playerID':player,'POS':tracker['POS'][id_max]},ignore_index=True)
filtered_fielding_sample

# add postion data 
new_filtered_sample = filtered_batting_sample.merge(filtered_fielding_sample, how = 'left')

# add salary data
new_filtered_sample['salary']=[sample_1999[sample_1999['playerID'].isin([player])].reset_index()['salary'][0] for player in players]
new_filtered_sample = new_filtered_sample.dropna()
new_filtered_sample

plt.figure(figsize = (20,10))
sns.heatmap(new_filtered_sample.corr(),annot = True,linewidth = 0.5)

features=['G','AB','R','3B','RBI','SB','BB','IBB','HBP','SF']

y = new_filtered_sample['salary']
x = new_filtered_sample[features]
train_x, val_x, train_y, val_y = train_test_split(x, y, random_state=1, test_size=0.4)
basic_model = DecisionTreeRegressor(random_state=1)
basic_model.fit(train_x, train_y)
predictions = basic_model.predict(val_x)

pd.set_option('display.float_format', lambda x: '%.0f' % x)

df = pd.DataFrame(val_x)
df['prediction'] = predictions
df['ID'] = [new_filtered_sample['playerID'][index] for index in df.reset_index()['index']]
df['POS']=[new_filtered_sample['POS'][index] for index in df.reset_index()['index']]
df['salary']=[new_filtered_sample['salary'][index] for index in df.reset_index()['index']]
# df=df[['name','ID','ab','r','h','double','rbi','bb','pos','salary','prediction']]
df['prediction'].apply(lambda x: '%.5f' % x)
df['difference'] = df['salary'] - df['prediction']
print(abs(df['difference']).mean())
print(df['salary'].mean())
df

"""following code is trying to use svm to train the model that can perdict position for each player"""

def sample_generate(svm_year):
  svm_sample_batting = batting[batting['yearID'].isin([svm_year])]

  svm_batting_dict = svm_sample_batting['playerID'].value_counts().to_dict()
  player_dict = {key: val for key, val in svm_batting_dict.items() if val == 1}

  # get all player with one batting in a list
  svm_players = list(player_dict.keys())
  svm_sample_batting = svm_sample_batting[svm_sample_batting['playerID'].isin(svm_players)]

  svm_players = svm_sample_batting['playerID'].value_counts().index
  svm_sample_fielding = fielding[fielding['yearID'].isin([svm_year]) & fielding['playerID'].isin(svm_players)]
  svm_filtered_fielding = pd.DataFrame()
  for player in svm_players:
      player_df = svm_sample_fielding[svm_sample_fielding['playerID'].isin([player])]
      positions = player_df['POS'].value_counts().index
      tracker = pd.DataFrame()
      for position in positions:
          df_temp = player_df[player_df['POS'].isin([position])]
          tracker = tracker.append({'POS':position, 'games':df_temp.sum()['G']}, ignore_index=True)
      if len(tracker.index) == 0:
        pass
      else:
        id_max = tracker['games'].idxmax()
        svm_filtered_fielding = svm_filtered_fielding.append({'playerID':player,'POS':tracker['POS'][id_max]},ignore_index=True)

  svm_players = svm_filtered_fielding['playerID'].value_counts().index
  svm_sample_batting = svm_sample_batting[svm_sample_batting['playerID'].isin(svm_players)]
  for i in range(len(svm_filtered_fielding['playerID'])):
    if svm_filtered_fielding['POS'][i] == 'P':
      svm_filtered_fielding['POS'][i] = 1
    else:
      svm_filtered_fielding['POS'][i] = -1

  svm_final_sample = svm_sample_batting.merge(svm_filtered_fielding, how = 'left')
  return svm_final_sample

svm_sample = sample_generate(2000).dropna()
svm_test = sample_generate(2001).dropna()

from sklearn import svm
svm_features=['G','AB','R','3B','RBI','SB','BB','IBB','HBP','SF']
y = svm_sample['POS'].to_numpy().astype('float64')
X = svm_sample[svm_features].to_numpy().astype('float64')
clf = svm.SVC()
clf.fit(X, y)

y_test = svm_test['POS'].to_numpy().astype('float64')
X_test = svm_test[svm_features].to_numpy().astype('float64')
res = clf.predict(X_test)
res

right_count = 0
for i in range(res.shape[0]):
  if res[i] == y_test[i]:
    right_count += 1
print(right_count/len(res))